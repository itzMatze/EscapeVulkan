#version 460

#extension GL_GOOGLE_include_directive: require
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(constant_id = 0) const uint SAMPLES_PER_SEGMENT = 1;
layout(constant_id = 1) const uint VERTICES_PER_SAMPLE = 1;

layout(binding = 0) buffer index_buffer {
    uint indices[];
};

layout(binding = 1) buffer vertex_buffer {
    AlignedVertex vertices[];
};

layout(push_constant) uniform PushConstant {
    ComputePushConstants pc;
};

// rotate v around k by angle degrees
vec3 rotate(vec3 v, vec3 k, float angle)
{
    float cos_theta = cos(radians(angle));
    float sin_theta = sin(radians(angle));
    vec3 rotated = (v * cos_theta) + (cross(k, v) * sin_theta) + (k * dot(k, v)) * (1 - cos_theta);
    return rotated;
}

void main()
{
    if (gl_GlobalInvocationID.x >= SAMPLES_PER_SEGMENT * VERTICES_PER_SAMPLE) return;
    // what circle of vertices this thread belongs to
    uint sample_circle_id = gl_GlobalInvocationID.x / VERTICES_PER_SAMPLE;
    // what vertex in the circle this thread belongs to
    uint vertex_id = gl_GlobalInvocationID.x % VERTICES_PER_SAMPLE;
    // interpolate over bÃ©zier points to get position and normal of sample
    float t = float(sample_circle_id) / float(SAMPLES_PER_SEGMENT - 1);
    vec3 sample_pos = pow(1 - t, 2) * pc.p0 + (2 - 2 * t) * t * pc.p1 + pow(t, 2) * pc.p2;
    // normal is given by derivative
    vec3 plane_normal = normalize((2 - 2 * t) * (pc.p1 - pc.p0) + 2 * t * (pc.p2 - pc.p1));
    // calculate vector that lies in the plane of the circle
    vec3 plane_vector = abs(dot(plane_normal, vec3(1.0, 0.0, 0.0))) >= 0.999999 ? cross(plane_normal, vec3(0.0, 0.0, 1.0)) : cross(plane_normal, vec3(1.0, 0.0, 0.0));
    // vector from center of circle to vertex position
    vec3 vertex_pos = normalize(rotate(plane_vector, plane_normal, (360.0 / VERTICES_PER_SAMPLE) * vertex_id));
    vertex_pos *= 20.0;
    // actual position of vertex
    vertex_pos += sample_pos;
    vec3 normal = normalize(sample_pos - vertex_pos);

    vertices[indices[pc.indices_start_idx] + gl_GlobalInvocationID.x].pos_normal_x = vec4(vertex_pos, normal.x);
    vertices[indices[pc.indices_start_idx] + gl_GlobalInvocationID.x].normal_yz_color_rg = vec4(normal.yz, 0.0, 0.0);
    vertices[indices[pc.indices_start_idx] + gl_GlobalInvocationID.x].color_ba_tex = vec4(0.8, 1.0, float(sample_circle_id) / float(SAMPLES_PER_SEGMENT - 1), float(vertex_id) / float(VERTICES_PER_SAMPLE - 1));
}
